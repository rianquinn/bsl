<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: bsl::reference_wrapper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebsl.html">bsl</a></li><li class="navelem"><a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbsl_1_1reference__wrapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bsl::reference_wrapper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classbsl_1_1reference__wrapper.html" title="reference_wrapper prototype">reference_wrapper</a> prototype  
 <a href="classbsl_1_1reference__wrapper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="is__reference__wrapper_8hpp_source.html">is_reference_wrapper.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adfbeae964054d28c3b3cd39ad98b8751"><td class="memTemplParams" colspan="2">template&lt;typename U , enable_if_t&lt;!is_same&lt; decay_t&lt; U &gt;, reference_wrapper &gt;::value &gt;  = true, typename  = decltype(details::FUN&lt;T&gt;(declval&lt;U&gt;()))&gt; </td></tr>
<tr class="memitem:adfbeae964054d28c3b3cd39ad98b8751"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbsl_1_1reference__wrapper.html#adfbeae964054d28c3b3cd39ad98b8751">reference_wrapper</a> (U &amp;&amp;val) noexcept(noexcept(details::FUN&lt; T &gt;(<a class="el" href="namespacebsl.html#ad7f937baf04563f2ff88472912aa6148">bsl::forward</a>&lt; U &gt;(val))))</td></tr>
<tr class="memdesc:adfbeae964054d28c3b3cd39ad98b8751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to initialize a <a class="el" href="classbsl_1_1reference__wrapper.html" title="reference_wrapper prototype">reference_wrapper</a> by getting an address to the provided "val" and storing the address for use later.  <a href="classbsl_1_1reference__wrapper.html#adfbeae964054d28c3b3cd39ad98b8751">More...</a><br /></td></tr>
<tr class="separator:adfbeae964054d28c3b3cd39ad98b8751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a12109ab56957ba0f5f353d401ed22"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1reference__wrapper.html#a84a12109ab56957ba0f5f353d401ed22">reference_wrapper</a> (<a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a> const &amp;o) noexcept=default</td></tr>
<tr class="memdesc:a84a12109ab56957ba0f5f353d401ed22"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classbsl_1_1reference__wrapper.html#a84a12109ab56957ba0f5f353d401ed22">More...</a><br /></td></tr>
<tr class="separator:a84a12109ab56957ba0f5f353d401ed22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951c7e8a13ced1a1c32eec97e314d8b2"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1reference__wrapper.html#a951c7e8a13ced1a1c32eec97e314d8b2">reference_wrapper</a> (<a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a> &amp;&amp;o) noexcept=default</td></tr>
<tr class="memdesc:a951c7e8a13ced1a1c32eec97e314d8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="classbsl_1_1reference__wrapper.html#a951c7e8a13ced1a1c32eec97e314d8b2">More...</a><br /></td></tr>
<tr class="separator:a951c7e8a13ced1a1c32eec97e314d8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffc3be3a936024d6aaaecc49860d6ba"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1reference__wrapper.html#a7ffc3be3a936024d6aaaecc49860d6ba">operator=</a> (<a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a> const &amp;o) &amp;noexcept=default</td></tr>
<tr class="memdesc:a7ffc3be3a936024d6aaaecc49860d6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assignment  <a href="classbsl_1_1reference__wrapper.html#a7ffc3be3a936024d6aaaecc49860d6ba">More...</a><br /></td></tr>
<tr class="separator:a7ffc3be3a936024d6aaaecc49860d6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2e82ef6e160dc85361f8e8f4c3d1cf"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1reference__wrapper.html#a9e2e82ef6e160dc85361f8e8f4c3d1cf">operator=</a> (<a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a> &amp;&amp;o) &amp;noexcept=default</td></tr>
<tr class="memdesc:a9e2e82ef6e160dc85361f8e8f4c3d1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assignment  <a href="classbsl_1_1reference__wrapper.html#a9e2e82ef6e160dc85361f8e8f4c3d1cf">More...</a><br /></td></tr>
<tr class="separator:a9e2e82ef6e160dc85361f8e8f4c3d1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3359062d2c1800796fa3c208a5e51e12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1reference__wrapper.html#a3359062d2c1800796fa3c208a5e51e12">~reference_wrapper</a> () noexcept=default</td></tr>
<tr class="memdesc:a3359062d2c1800796fa3c208a5e51e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroyes a previously created <a class="el" href="classbsl_1_1reference__wrapper.html" title="reference_wrapper prototype">bsl::reference_wrapper</a>.  <a href="classbsl_1_1reference__wrapper.html#a3359062d2c1800796fa3c208a5e51e12">More...</a><br /></td></tr>
<tr class="separator:a3359062d2c1800796fa3c208a5e51e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561a78479265220bb3f6750f8fa90c7c"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1reference__wrapper.html#a561a78479265220bb3f6750f8fa90c7c">get</a> () const noexcept</td></tr>
<tr class="memdesc:a561a78479265220bb3f6750f8fa90c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the thing that is wrapped. This is done by taking the stored address and returning a reference instead of an address.  <a href="classbsl_1_1reference__wrapper.html#a561a78479265220bb3f6750f8fa90c7c">More...</a><br /></td></tr>
<tr class="separator:a561a78479265220bb3f6750f8fa90c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0454ca90ef59a8c61dba208d50114b35"><td class="memTemplParams" colspan="2">template&lt;typename... ARGS&gt; </td></tr>
<tr class="memitem:a0454ca90ef59a8c61dba208d50114b35"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#ad734e41c64ad6aa419a9ec6bf642f39e">invoke_result_t</a>&lt; T &amp;, ARGS... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbsl_1_1reference__wrapper.html#a0454ca90ef59a8c61dba208d50114b35">operator()</a> (ARGS &amp;&amp;... a) const</td></tr>
<tr class="memdesc:a0454ca90ef59a8c61dba208d50114b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the <a class="el" href="classbsl_1_1reference__wrapper.html" title="reference_wrapper prototype">reference_wrapper</a> as if it were a function.  <a href="classbsl_1_1reference__wrapper.html#a0454ca90ef59a8c61dba208d50114b35">More...</a><br /></td></tr>
<tr class="separator:a0454ca90ef59a8c61dba208d50114b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classbsl_1_1reference__wrapper.html" title="reference_wrapper prototype">reference_wrapper</a> prototype </p>
<p><a class="el" href="classbsl_1_1reference__wrapper.html" title="reference_wrapper prototype">bsl::reference_wrapper</a> is a class template that wraps a reference. Unlike the std::reference_wrapper, the implicit conversion operator is not supported as that would not be compliant with AUTOSAR. We also do not add the assignment operator as that would result in needing to define the rule of 5 which is not needed (there is no harm in allowing moves as they result in the same thing as a copy).</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef EXAMPLE_REFERENCE_WRAPPER_OVERVIEW_HPP</span></div>
<div class="line"><span class="preprocessor">#define EXAMPLE_REFERENCE_WRAPPER_OVERVIEW_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="reference__wrapper_8hpp.html">bsl/reference_wrapper.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line">    example_reference_wrapper_overview() noexcept</div>
<div class="line">    {</div>
<div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> expected{42};</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> data{};</div>
<div class="line">        <a class="code" href="classbsl_1_1reference__wrapper.html">bsl::reference_wrapper</a> <span class="keyword">const</span> rw{data};</div>
<div class="line"> </div>
<div class="line">        rw.<a class="code" href="classbsl_1_1reference__wrapper.html#a561a78479265220bb3f6750f8fa90c7c">get</a>() = expected;</div>
<div class="line">        <span class="keywordflow">if</span> (expected == data) {</div>
<div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of reference to wrap </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adfbeae964054d28c3b3cd39ad98b8751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbeae964054d28c3b3cd39ad98b8751">&#9670;&nbsp;</a></span>reference_wrapper() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , enable_if_t&lt;!is_same&lt; decay_t&lt; U &gt;, reference_wrapper &gt;::value &gt;  = true, typename  = decltype(details::FUN&lt;T&gt;(declval&lt;U&gt;()))&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bsl::reference_wrapper::reference_wrapper </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to initialize a <a class="el" href="classbsl_1_1reference__wrapper.html" title="reference_wrapper prototype">reference_wrapper</a> by getting an address to the provided "val" and storing the address for use later. </p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef EXAMPLE_REFERENCE_WRAPPER_CONSTRUCTOR_HPP</span></div>
<div class="line"><span class="preprocessor">#define EXAMPLE_REFERENCE_WRAPPER_CONSTRUCTOR_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="reference__wrapper_8hpp.html">bsl/reference_wrapper.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line">    example_reference_wrapper_constructor() noexcept</div>
<div class="line">    {</div>
<div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> expected{42};</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> data{};</div>
<div class="line">        <a class="code" href="classbsl_1_1reference__wrapper.html">bsl::reference_wrapper</a> <span class="keyword">const</span> rw{data};</div>
<div class="line"> </div>
<div class="line">        rw.<a class="code" href="classbsl_1_1reference__wrapper.html#a561a78479265220bb3f6750f8fa90c7c">get</a>() = expected;</div>
<div class="line">        <span class="keywordflow">if</span> (expected == data) {</div>
<div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>SUPPRESSION: PRQA 2023 - exception required</p><ul>
<li>We suppress this because A13-3-1 states that you should not overload functions that contain a forwarding reference because it is confusing to the user. In this case, there is nothing ambiguous about this situation as there is only one constructor so there are no additional constructors to confuse the API with. It should also be noted that the C++ specificatino states that this is how std::reference_wrapper should be implemented.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>none</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type that defines "val" </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the thing to get the address of and store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>if converting U to T throws </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84a12109ab56957ba0f5f353d401ed22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a12109ab56957ba0f5f353d401ed22">&#9670;&nbsp;</a></span>reference_wrapper() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bsl::reference_wrapper::reference_wrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a> const &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<p>SUPPRESSION: PRQA 2023 - exception required</p><ul>
<li>We suppress this because A13-3-1 states that you should not overload functions that contain a forwarding reference because it is confusing to the user. In this case, there is nothing ambiguous about this situation as there is only one constructor so there are no additional constructors to confuse the API with. It should also be noted that the C++ specificatino states that this is how std::reference_wrapper should be implemented.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the object being copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a951c7e8a13ced1a1c32eec97e314d8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951c7e8a13ced1a1c32eec97e314d8b2">&#9670;&nbsp;</a></span>reference_wrapper() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bsl::reference_wrapper::reference_wrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>
<p>SUPPRESSION: PRQA 2023 - exception required</p><ul>
<li>We suppress this because A13-3-1 states that you should not overload functions that contain a forwarding reference because it is confusing to the user. In this case, there is nothing ambiguous about this situation as there is only one constructor so there are no additional constructors to confuse the API with. It should also be noted that the C++ specificatino states that this is how std::reference_wrapper should be implemented.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the object being moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3359062d2c1800796fa3c208a5e51e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3359062d2c1800796fa3c208a5e51e12">&#9670;&nbsp;</a></span>~reference_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bsl::reference_wrapper::~reference_wrapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroyes a previously created <a class="el" href="classbsl_1_1reference__wrapper.html" title="reference_wrapper prototype">bsl::reference_wrapper</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>none </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7ffc3be3a936024d6aaaecc49860d6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffc3be3a936024d6aaaecc49860d6ba">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a>&amp; bsl::reference_wrapper::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a> const &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy assignment </p>
<p>SUPPRESSION: PRQA 2023 - exception required</p><ul>
<li>We suppress this because A13-3-1 states that you should not overload functions that contain a forwarding reference because it is confusing to the user. In this case, there is nothing ambiguous about this situation as there is only one constructor so there are no additional constructors to confuse the API with. It should also be noted that the C++ specificatino states that this is how std::reference_wrapper should be implemented.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the object being copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this </dd></dl>

</div>
</div>
<a id="a9e2e82ef6e160dc85361f8e8f4c3d1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2e82ef6e160dc85361f8e8f4c3d1cf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a>&amp; bsl::reference_wrapper::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move assignment </p>
<p>SUPPRESSION: PRQA 2023 - exception required</p><ul>
<li>We suppress this because A13-3-1 states that you should not overload functions that contain a forwarding reference because it is confusing to the user. In this case, there is nothing ambiguous about this situation as there is only one constructor so there are no additional constructors to confuse the API with. It should also be noted that the C++ specificatino states that this is how std::reference_wrapper should be implemented.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the object being moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this </dd></dl>

</div>
</div>
<a id="a561a78479265220bb3f6750f8fa90c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561a78479265220bb3f6750f8fa90c7c">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; bsl::reference_wrapper::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the thing that is wrapped. This is done by taking the stored address and returning a reference instead of an address. </p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef EXAMPLE_REFERENCE_WRAPPER_GET_HPP</span></div>
<div class="line"><span class="preprocessor">#define EXAMPLE_REFERENCE_WRAPPER_GET_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="reference__wrapper_8hpp.html">bsl/reference_wrapper.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line">    example_reference_wrapper_get() noexcept</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> <span class="keyword">const</span> data{42};</div>
<div class="line">        <a class="code" href="classbsl_1_1reference__wrapper.html">bsl::reference_wrapper</a> <span class="keyword">const</span> rw{data};</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (rw.get() == data) {</div>
<div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the wrapped thing </dd></dl>

</div>
</div>
<a id="a0454ca90ef59a8c61dba208d50114b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0454ca90ef59a8c61dba208d50114b35">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#ad734e41c64ad6aa419a9ec6bf642f39e">invoke_result_t</a>&lt;T &amp;, ARGS...&gt; bsl::reference_wrapper::operator() </td>
          <td>(</td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the <a class="el" href="classbsl_1_1reference__wrapper.html" title="reference_wrapper prototype">reference_wrapper</a> as if it were a function. </p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef EXAMPLE_REFERENCE_WRAPPER_FUNCTOR_HPP</span></div>
<div class="line"><span class="preprocessor">#define EXAMPLE_REFERENCE_WRAPPER_FUNCTOR_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="reference__wrapper_8hpp.html">bsl/reference_wrapper.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;../example_function.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line">    example_reference_wrapper_functor() noexcept</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classbsl_1_1reference__wrapper.html">bsl::reference_wrapper</a> <span class="keyword">const</span> rw{example_function};</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (rw(<span class="keyword">true</span>)) {</div>
<div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>none</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ARGS</td><td>the types of arguments to pass to the wrapped function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the arguments to pass to the wrapped function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the wrapped function given the provided arguments.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>if the wrapped function throws </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/bsl/<a class="el" href="is__reference__wrapper_8hpp_source.html">is_reference_wrapper.hpp</a></li>
<li>include/bsl/<a class="el" href="reference__wrapper_8hpp_source.html">reference_wrapper.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="areference__wrapper_8hpp_html"><div class="ttname"><a href="reference__wrapper_8hpp.html">reference_wrapper.hpp</a></div></div>
<div class="ttc" id="aclassbsl_1_1reference__wrapper_html_a561a78479265220bb3f6750f8fa90c7c"><div class="ttname"><a href="classbsl_1_1reference__wrapper.html#a561a78479265220bb3f6750f8fa90c7c">bsl::reference_wrapper::get</a></div><div class="ttdeci">constexpr T &amp; get() const noexcept</div><div class="ttdoc">Returns a reference to the thing that is wrapped. This is done by taking the stored address and retur...</div><div class="ttdef"><b>Definition:</b> reference_wrapper.hpp:247</div></div>
<div class="ttc" id="anamespacebsl_html_ad7463e35f2d5163201b51201e7cc6e33"><div class="ttname"><a href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a></div><div class="ttdeci">::int32_t int32</div><div class="ttdoc">defines an 32bit signed integer</div><div class="ttdef"><b>Definition:</b> cstdint.hpp:40</div></div>
<div class="ttc" id="aclassbsl_1_1reference__wrapper_html"><div class="ttname"><a href="classbsl_1_1reference__wrapper.html">bsl::reference_wrapper</a></div><div class="ttdoc">reference_wrapper prototype</div><div class="ttdef"><b>Definition:</b> is_reference_wrapper.hpp:38</div></div>
<div class="ttc" id="anamespacebsl_html_a88c46da64489ced5d04ef124d7ffbd70"><div class="ttname"><a href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a></div><div class="ttdeci">constexpr void print(CharT const (&amp;fmt)[N], ARGS &amp;&amp;... args) noexcept</div><div class="ttdoc">Provides a printf like function that is implemented using a technique similar to the technique implem...</div><div class="ttdef"><b>Definition:</b> print.hpp:56</div></div>
<div class="ttc" id="aprint_8hpp_html"><div class="ttname"><a href="print_8hpp.html">print.hpp</a></div></div>
<div class="ttc" id="anamespacebsl_html"><div class="ttname"><a href="namespacebsl.html">bsl</a></div><div class="ttdef"><b>Definition:</b> add_const.hpp:33</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
